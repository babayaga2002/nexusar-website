{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/sidharthchoudhary/nexusar-website/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sidharthchoudhary/nexusar-website/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar xml2js = require('xml2js');\n\nvar url = require('url');\n\nvar fields = require('./fields');\n\nvar utils = require('./utils');\n\nvar DEFAULT_HEADERS = {\n  'User-Agent': 'rss-parser',\n  'Accept': 'application/rss+xml'\n};\nvar DEFAULT_MAX_REDIRECTS = 5;\nvar DEFAULT_TIMEOUT = 60000;\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Parser);\n\n    options.headers = options.headers || {};\n    options.xml2js = options.xml2js || {};\n    options.customFields = options.customFields || {};\n    options.customFields.item = options.customFields.item || [];\n    options.customFields.feed = options.customFields.feed || [];\n    options.requestOptions = options.requestOptions || {};\n    if (!options.maxRedirects) options.maxRedirects = DEFAULT_MAX_REDIRECTS;\n    if (!options.timeout) options.timeout = DEFAULT_TIMEOUT;\n    this.options = options;\n    this.xmlParser = new xml2js.Parser(this.options.xml2js);\n  }\n\n  _createClass(Parser, [{\n    key: \"parseString\",\n    value: function parseString(xml, callback) {\n      var _this = this;\n\n      var prom = new Promise(function (resolve, reject) {\n        _this.xmlParser.parseString(xml, function (err, result) {\n          if (err) return reject(err);\n\n          if (!result) {\n            return reject(new Error('Unable to parse XML.'));\n          }\n\n          var feed = null;\n\n          if (result.feed) {\n            feed = _this.buildAtomFeed(result);\n          } else if (result.rss && result.rss.$ && result.rss.$.version && result.rss.$.version.match(/^2/)) {\n            feed = _this.buildRSS2(result);\n          } else if (result['rdf:RDF']) {\n            feed = _this.buildRSS1(result);\n          } else if (result.rss && result.rss.$ && result.rss.$.version && result.rss.$.version.match(/0\\.9/)) {\n            feed = _this.buildRSS0_9(result);\n          } else if (result.rss && _this.options.defaultRSS) {\n            switch (_this.options.defaultRSS) {\n              case 0.9:\n                feed = _this.buildRSS0_9(result);\n                break;\n\n              case 1:\n                feed = _this.buildRSS1(result);\n                break;\n\n              case 2:\n                feed = _this.buildRSS2(result);\n                break;\n\n              default:\n                return reject(new Error(\"default RSS version not recognized.\"));\n            }\n          } else {\n            return reject(new Error(\"Feed not recognized as RSS 1 or 2.\"));\n          }\n\n          resolve(feed);\n        });\n      });\n      prom = utils.maybePromisify(callback, prom);\n      return prom;\n    }\n  }, {\n    key: \"parseURL\",\n    value: function parseURL(feedUrl, callback) {\n      var _this2 = this;\n\n      var redirectCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var xml = '';\n      var get = feedUrl.indexOf('https') === 0 ? https.get : http.get;\n      var urlParts = url.parse(feedUrl);\n      var headers = Object.assign({}, DEFAULT_HEADERS, this.options.headers);\n      var timeout = null;\n      var prom = new Promise(function (resolve, reject) {\n        var requestOpts = Object.assign({\n          headers: headers\n        }, urlParts, _this2.options.requestOptions);\n        var req = get(requestOpts, function (res) {\n          if (_this2.options.maxRedirects && res.statusCode >= 300 && res.statusCode < 400 && res.headers['location']) {\n            if (redirectCount === _this2.options.maxRedirects) {\n              return reject(new Error(\"Too many redirects\"));\n            } else {\n              var newLocation = url.resolve(feedUrl, res.headers['location']);\n              return _this2.parseURL(newLocation, null, redirectCount + 1).then(resolve, reject);\n            }\n          } else if (res.statusCode >= 300) {\n            return reject(new Error(\"Status code \" + res.statusCode));\n          }\n\n          var encoding = utils.getEncodingFromContentType(res.headers['content-type']);\n          res.setEncoding(encoding);\n          res.on('data', function (chunk) {\n            xml += chunk;\n          });\n          res.on('end', function () {\n            return _this2.parseString(xml).then(resolve, reject);\n          });\n        });\n        req.on('error', reject);\n        timeout = setTimeout(function () {\n          return reject(new Error(\"Request timed out after \" + _this2.options.timeout + \"ms\"));\n        }, _this2.options.timeout);\n      }).then(function (data) {\n        clearTimeout(timeout);\n        return Promise.resolve(data);\n      }, function (e) {\n        clearTimeout(timeout);\n        return Promise.reject(e);\n      });\n      prom = utils.maybePromisify(callback, prom);\n      return prom;\n    }\n  }, {\n    key: \"buildAtomFeed\",\n    value: function buildAtomFeed(xmlObj) {\n      var _this3 = this;\n\n      var feed = {\n        items: []\n      };\n      utils.copyFromXML(xmlObj.feed, feed, this.options.customFields.feed);\n\n      if (xmlObj.feed.link) {\n        feed.link = utils.getLink(xmlObj.feed.link, 'alternate', 0);\n        feed.feedUrl = utils.getLink(xmlObj.feed.link, 'self', 1);\n      }\n\n      if (xmlObj.feed.title) {\n        var title = xmlObj.feed.title[0] || '';\n        if (title._) title = title._;\n        if (title) feed.title = title;\n      }\n\n      if (xmlObj.feed.updated) {\n        feed.lastBuildDate = xmlObj.feed.updated[0];\n      }\n\n      feed.items = (xmlObj.feed.entry || []).map(function (entry) {\n        return _this3.parseItemAtom(entry);\n      });\n      return feed;\n    }\n  }, {\n    key: \"parseItemAtom\",\n    value: function parseItemAtom(entry) {\n      var item = {};\n      utils.copyFromXML(entry, item, this.options.customFields.item);\n\n      if (entry.title) {\n        var title = entry.title[0] || '';\n        if (title._) title = title._;\n        if (title) item.title = title;\n      }\n\n      if (entry.link && entry.link.length) {\n        item.link = utils.getLink(entry.link, 'alternate', 0);\n      }\n\n      if (entry.published && entry.published.length && entry.published[0].length) item.pubDate = new Date(entry.published[0]).toISOString();\n      if (!item.pubDate && entry.updated && entry.updated.length && entry.updated[0].length) item.pubDate = new Date(entry.updated[0]).toISOString();\n      if (entry.author && entry.author.length && entry.author[0].name && entry.author[0].name.length) item.author = entry.author[0].name[0];\n\n      if (entry.content && entry.content.length) {\n        item.content = utils.getContent(entry.content[0]);\n        item.contentSnippet = utils.getSnippet(item.content);\n      }\n\n      if (entry.summary && entry.summary.length) {\n        item.summary = utils.getContent(entry.summary[0]);\n      }\n\n      if (entry.id) {\n        item.id = entry.id[0];\n      }\n\n      this.setISODate(item);\n      return item;\n    }\n  }, {\n    key: \"buildRSS0_9\",\n    value: function buildRSS0_9(xmlObj) {\n      var channel = xmlObj.rss.channel[0];\n      var items = channel.item;\n      return this.buildRSS(channel, items);\n    }\n  }, {\n    key: \"buildRSS1\",\n    value: function buildRSS1(xmlObj) {\n      xmlObj = xmlObj['rdf:RDF'];\n      var channel = xmlObj.channel[0];\n      var items = xmlObj.item;\n      return this.buildRSS(channel, items);\n    }\n  }, {\n    key: \"buildRSS2\",\n    value: function buildRSS2(xmlObj) {\n      var channel = xmlObj.rss.channel[0];\n      var items = channel.item;\n      var feed = this.buildRSS(channel, items);\n\n      if (xmlObj.rss.$ && xmlObj.rss.$['xmlns:itunes']) {\n        this.decorateItunes(feed, channel);\n      }\n\n      return feed;\n    }\n  }, {\n    key: \"buildRSS\",\n    value: function buildRSS(channel, items) {\n      var _this4 = this;\n\n      items = items || [];\n      var feed = {\n        items: []\n      };\n      var feedFields = fields.feed.concat(this.options.customFields.feed);\n      var itemFields = fields.item.concat(this.options.customFields.item);\n\n      if (channel['atom:link'] && channel['atom:link'][0] && channel['atom:link'][0].$) {\n        feed.feedUrl = channel['atom:link'][0].$.href;\n      }\n\n      if (channel.image && channel.image[0] && channel.image[0].url) {\n        feed.image = {};\n        var image = channel.image[0];\n        if (image.link) feed.image.link = image.link[0];\n        if (image.url) feed.image.url = image.url[0];\n        if (image.title) feed.image.title = image.title[0];\n        if (image.width) feed.image.width = image.width[0];\n        if (image.height) feed.image.height = image.height[0];\n      }\n\n      var paginationLinks = this.generatePaginationLinks(channel);\n\n      if (Object.keys(paginationLinks).length) {\n        feed.paginationLinks = paginationLinks;\n      }\n\n      utils.copyFromXML(channel, feed, feedFields);\n      feed.items = items.map(function (xmlItem) {\n        return _this4.parseItemRss(xmlItem, itemFields);\n      });\n      return feed;\n    }\n  }, {\n    key: \"parseItemRss\",\n    value: function parseItemRss(xmlItem, itemFields) {\n      var item = {};\n      utils.copyFromXML(xmlItem, item, itemFields);\n\n      if (xmlItem.enclosure) {\n        item.enclosure = xmlItem.enclosure[0].$;\n      }\n\n      if (xmlItem.description) {\n        item.content = utils.getContent(xmlItem.description[0]);\n        item.contentSnippet = utils.getSnippet(item.content);\n      }\n\n      if (xmlItem.guid) {\n        item.guid = xmlItem.guid[0];\n        if (item.guid._) item.guid = item.guid._;\n      }\n\n      if (xmlItem.category) item.categories = xmlItem.category;\n      this.setISODate(item);\n      return item;\n    }\n    /**\n     * Add iTunes specific fields from XML to extracted JSON\n     *\n     * @access public\n     * @param {object} feed extracted\n     * @param {object} channel parsed XML\n     */\n\n  }, {\n    key: \"decorateItunes\",\n    value: function decorateItunes(feed, channel) {\n      var items = channel.item || [];\n      var categories = [];\n      feed.itunes = {};\n\n      if (channel['itunes:owner']) {\n        var owner = {};\n\n        if (channel['itunes:owner'][0]['itunes:name']) {\n          owner.name = channel['itunes:owner'][0]['itunes:name'][0];\n        }\n\n        if (channel['itunes:owner'][0]['itunes:email']) {\n          owner.email = channel['itunes:owner'][0]['itunes:email'][0];\n        }\n\n        feed.itunes.owner = owner;\n      }\n\n      if (channel['itunes:image']) {\n        var image;\n        var hasImageHref = channel['itunes:image'][0] && channel['itunes:image'][0].$ && channel['itunes:image'][0].$.href;\n        image = hasImageHref ? channel['itunes:image'][0].$.href : null;\n\n        if (image) {\n          feed.itunes.image = image;\n        }\n      }\n\n      if (channel['itunes:category']) {\n        var categoriesWithSubs = channel['itunes:category'].map(function (category) {\n          return {\n            name: category.$.text,\n            subs: category['itunes:category'] ? category['itunes:category'].map(function (subcategory) {\n              return {\n                name: subcategory.$.text\n              };\n            }) : null\n          };\n        });\n        feed.itunes.categories = categoriesWithSubs.map(function (category) {\n          return category.name;\n        });\n        feed.itunes.categoriesWithSubs = categoriesWithSubs;\n      }\n\n      if (channel['itunes:keywords']) {\n        if (channel['itunes:keywords'].length > 1) {\n          feed.itunes.keywords = channel['itunes:keywords'].map(function (keyword) {\n            return keyword.$.text;\n          });\n        } else {\n          var keywords = channel['itunes:keywords'][0];\n\n          if (keywords && typeof keywords._ === 'string') {\n            keywords = keywords._;\n          }\n\n          if (keywords && keywords.$ && keywords.$.text) {\n            feed.itunes.keywords = keywords.$.text.split(',');\n          } else if (typeof keywords === \"string\") {\n            feed.itunes.keywords = keywords.split(',');\n          }\n        }\n      }\n\n      utils.copyFromXML(channel, feed.itunes, fields.podcastFeed);\n      items.forEach(function (item, index) {\n        var entry = feed.items[index];\n        entry.itunes = {};\n        utils.copyFromXML(item, entry.itunes, fields.podcastItem);\n        var image = item['itunes:image'];\n\n        if (image && image[0] && image[0].$ && image[0].$.href) {\n          entry.itunes.image = image[0].$.href;\n        }\n      });\n    }\n  }, {\n    key: \"setISODate\",\n    value: function setISODate(item) {\n      var date = item.pubDate || item.date;\n\n      if (date) {\n        try {\n          item.isoDate = new Date(date.trim()).toISOString();\n        } catch (e) {// Ignore bad date format\n        }\n      }\n    }\n    /**\n     * Generates a pagination object where the rel attribute is the key and href attribute is the value\n     *  { self: 'self-url', first: 'first-url', ...  }\n     *\n     * @access private\n     * @param {Object} channel parsed XML\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"generatePaginationLinks\",\n    value: function generatePaginationLinks(channel) {\n      if (!channel['atom:link']) {\n        return {};\n      }\n\n      var paginationRelAttributes = ['self', 'first', 'next', 'prev', 'last'];\n      return channel['atom:link'].reduce(function (paginationLinks, link) {\n        if (!link.$ || !paginationRelAttributes.includes(link.$.rel)) {\n          return paginationLinks;\n        }\n\n        paginationLinks[link.$.rel] = link.$.href;\n        return paginationLinks;\n      }, {});\n    }\n  }]);\n\n  return Parser;\n}();\n\nmodule.exports = Parser;","map":{"version":3,"sources":["/Users/sidharthchoudhary/nexusar-website/node_modules/rss-parser/lib/parser.js"],"names":["http","require","https","xml2js","url","fields","utils","DEFAULT_HEADERS","DEFAULT_MAX_REDIRECTS","DEFAULT_TIMEOUT","Parser","options","headers","customFields","item","feed","requestOptions","maxRedirects","timeout","xmlParser","xml","callback","prom","Promise","resolve","reject","parseString","err","result","Error","buildAtomFeed","rss","$","version","match","buildRSS2","buildRSS1","buildRSS0_9","defaultRSS","maybePromisify","feedUrl","redirectCount","get","indexOf","urlParts","parse","Object","assign","requestOpts","req","res","statusCode","newLocation","parseURL","then","encoding","getEncodingFromContentType","setEncoding","on","chunk","setTimeout","data","clearTimeout","e","xmlObj","items","copyFromXML","link","getLink","title","_","updated","lastBuildDate","entry","map","parseItemAtom","length","published","pubDate","Date","toISOString","author","name","content","getContent","contentSnippet","getSnippet","summary","id","setISODate","channel","buildRSS","decorateItunes","feedFields","concat","itemFields","href","image","width","height","paginationLinks","generatePaginationLinks","keys","xmlItem","parseItemRss","enclosure","description","guid","category","categories","itunes","owner","email","hasImageHref","categoriesWithSubs","text","subs","subcategory","keywords","keyword","split","podcastFeed","forEach","index","podcastItem","date","isoDate","trim","paginationRelAttributes","reduce","includes","rel","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nconst http = require('http');\nconst https = require('https');\nconst xml2js = require('xml2js');\nconst url = require('url');\n\nconst fields = require('./fields');\nconst utils = require('./utils');\n\nconst DEFAULT_HEADERS = {\n  'User-Agent': 'rss-parser',\n  'Accept': 'application/rss+xml',\n}\nconst DEFAULT_MAX_REDIRECTS = 5;\nconst DEFAULT_TIMEOUT = 60000;\n\nclass Parser {\n  constructor(options={}) {\n    options.headers = options.headers || {};\n    options.xml2js = options.xml2js || {};\n    options.customFields = options.customFields || {};\n    options.customFields.item = options.customFields.item || [];\n    options.customFields.feed = options.customFields.feed || [];\n    options.requestOptions = options.requestOptions || {};\n    if (!options.maxRedirects) options.maxRedirects = DEFAULT_MAX_REDIRECTS;\n    if (!options.timeout) options.timeout = DEFAULT_TIMEOUT;\n    this.options = options;\n    this.xmlParser = new xml2js.Parser(this.options.xml2js);\n  }\n\n  parseString(xml, callback) {\n    let prom = new Promise((resolve, reject) => {\n      this.xmlParser.parseString(xml, (err, result) => {\n        if (err) return reject(err);\n        if (!result) {\n          return reject(new Error('Unable to parse XML.'));\n        }\n        let feed = null;\n        if (result.feed) {\n          feed = this.buildAtomFeed(result);\n        } else if (result.rss && result.rss.$ && result.rss.$.version && result.rss.$.version.match(/^2/)) {\n          feed = this.buildRSS2(result);\n        } else if (result['rdf:RDF']) {\n          feed = this.buildRSS1(result);\n        } else if (result.rss && result.rss.$ && result.rss.$.version && result.rss.$.version.match(/0\\.9/)) {\n          feed = this.buildRSS0_9(result);\n        } else if (result.rss && this.options.defaultRSS) {\n          switch(this.options.defaultRSS) {\n            case 0.9:\n              feed = this.buildRSS0_9(result);\n              break;\n            case 1:\n              feed = this.buildRSS1(result);\n              break;\n            case 2:\n              feed = this.buildRSS2(result);\n              break;\n            default:\n              return reject(new Error(\"default RSS version not recognized.\"))\n          }\n        } else {\n          return reject(new Error(\"Feed not recognized as RSS 1 or 2.\"))\n        }\n        resolve(feed);\n      });\n    });\n    prom = utils.maybePromisify(callback, prom);\n    return prom;\n  }\n\n  parseURL(feedUrl, callback, redirectCount=0) {\n    let xml = '';\n    let get = feedUrl.indexOf('https') === 0 ? https.get : http.get;\n    let urlParts = url.parse(feedUrl);\n    let headers = Object.assign({}, DEFAULT_HEADERS, this.options.headers);\n    let timeout = null;\n    let prom = new Promise((resolve, reject) => {\n      const requestOpts = Object.assign({headers}, urlParts, this.options.requestOptions);\n      let req = get(requestOpts, (res) => {\n        if (this.options.maxRedirects && res.statusCode >= 300 && res.statusCode < 400 && res.headers['location']) {\n          if (redirectCount === this.options.maxRedirects) {\n            return reject(new Error(\"Too many redirects\"));\n          } else {\n            const newLocation = url.resolve(feedUrl, res.headers['location']);\n            return this.parseURL(newLocation, null, redirectCount + 1).then(resolve, reject);\n          }\n        } else if (res.statusCode >= 300) {\n          return reject(new Error(\"Status code \" + res.statusCode))\n        }\n        let encoding = utils.getEncodingFromContentType(res.headers['content-type']);\n        res.setEncoding(encoding);\n        res.on('data', (chunk) => {\n          xml += chunk;\n        });\n        res.on('end', () => {\n          return this.parseString(xml).then(resolve, reject);\n        });\n      })\n      req.on('error', reject);\n      timeout = setTimeout(() => {\n        return reject(new Error(\"Request timed out after \" + this.options.timeout + \"ms\"));\n      }, this.options.timeout);\n    }).then(data => {\n      clearTimeout(timeout);\n      return Promise.resolve(data);\n    }, e => {\n      clearTimeout(timeout);\n      return Promise.reject(e);\n    });\n    prom = utils.maybePromisify(callback, prom);\n    return prom;\n  }\n\n  buildAtomFeed(xmlObj) {\n    let feed = {items: []};\n    utils.copyFromXML(xmlObj.feed, feed, this.options.customFields.feed);\n    if (xmlObj.feed.link) {\n      feed.link = utils.getLink(xmlObj.feed.link, 'alternate', 0);\n      feed.feedUrl = utils.getLink(xmlObj.feed.link, 'self', 1);\n    }\n    if (xmlObj.feed.title) {\n      let title = xmlObj.feed.title[0] || '';\n      if (title._) title = title._\n      if (title) feed.title = title;\n    }\n    if (xmlObj.feed.updated) {\n      feed.lastBuildDate = xmlObj.feed.updated[0];\n    }\n    feed.items = (xmlObj.feed.entry || []).map(entry => this.parseItemAtom(entry));\n    return feed;\n  }\n\n  parseItemAtom(entry) {\n    let item = {};\n    utils.copyFromXML(entry, item, this.options.customFields.item);\n    if (entry.title) {\n      let title = entry.title[0] || '';\n      if (title._) title = title._;\n      if (title) item.title = title;\n    }\n    if (entry.link && entry.link.length) {\n      item.link = utils.getLink(entry.link, 'alternate', 0);\n    }\n    if (entry.published && entry.published.length && entry.published[0].length) item.pubDate = new Date(entry.published[0]).toISOString();\n    if (!item.pubDate && entry.updated && entry.updated.length && entry.updated[0].length) item.pubDate = new Date(entry.updated[0]).toISOString();\n    if (entry.author && entry.author.length && entry.author[0].name && entry.author[0].name.length) item.author = entry.author[0].name[0];\n    if (entry.content && entry.content.length) {\n      item.content = utils.getContent(entry.content[0]);\n      item.contentSnippet = utils.getSnippet(item.content)\n    }\n    if (entry.summary && entry.summary.length) {\n      item.summary = utils.getContent(entry.summary[0]);\n    }\n    if (entry.id) {\n      item.id = entry.id[0];\n    }\n    this.setISODate(item);\n    return item;\n  }\n\n  buildRSS0_9(xmlObj) {\n    var channel = xmlObj.rss.channel[0];\n    var items = channel.item;\n    return this.buildRSS(channel, items);\n  }\n\n  buildRSS1(xmlObj) {\n    xmlObj = xmlObj['rdf:RDF'];\n    let channel = xmlObj.channel[0];\n    let items = xmlObj.item;\n    return this.buildRSS(channel, items);\n  }\n\n  buildRSS2(xmlObj) {\n    let channel = xmlObj.rss.channel[0];\n    let items = channel.item;\n    let feed = this.buildRSS(channel, items);\n    if (xmlObj.rss.$ && xmlObj.rss.$['xmlns:itunes']) {\n      this.decorateItunes(feed, channel);\n    }\n    return feed;\n  }\n\n  buildRSS(channel, items) {\n    items = items || [];\n    let feed = {items: []};\n    let feedFields = fields.feed.concat(this.options.customFields.feed);\n    let itemFields = fields.item.concat(this.options.customFields.item);\n    if (channel['atom:link'] && channel['atom:link'][0] && channel['atom:link'][0].$) {\n      feed.feedUrl = channel['atom:link'][0].$.href;\n    }\n    if (channel.image && channel.image[0] && channel.image[0].url) {\n      feed.image = {};\n      let image = channel.image[0];\n      if (image.link) feed.image.link = image.link[0];\n      if (image.url) feed.image.url = image.url[0];\n      if (image.title) feed.image.title = image.title[0];\n      if (image.width) feed.image.width = image.width[0];\n      if (image.height) feed.image.height = image.height[0];\n    }\n    const paginationLinks = this.generatePaginationLinks(channel);\n    if (Object.keys(paginationLinks).length) {\n      feed.paginationLinks = paginationLinks;\n    }\n    utils.copyFromXML(channel, feed, feedFields);\n    feed.items = items.map(xmlItem => this.parseItemRss(xmlItem, itemFields));\n    return feed;\n  }\n\n  parseItemRss(xmlItem, itemFields) {\n    let item = {};\n    utils.copyFromXML(xmlItem, item, itemFields);\n    if (xmlItem.enclosure) {\n      item.enclosure = xmlItem.enclosure[0].$;\n    }\n    if (xmlItem.description) {\n      item.content = utils.getContent(xmlItem.description[0]);\n      item.contentSnippet = utils.getSnippet(item.content);\n    }\n    if (xmlItem.guid) {\n      item.guid = xmlItem.guid[0];\n      if (item.guid._) item.guid = item.guid._;\n    }\n    if (xmlItem.category) item.categories = xmlItem.category;\n    this.setISODate(item);\n    return item;\n  }\n\n  /**\n   * Add iTunes specific fields from XML to extracted JSON\n   *\n   * @access public\n   * @param {object} feed extracted\n   * @param {object} channel parsed XML\n   */\n  decorateItunes(feed, channel) {\n    let items = channel.item || [];\n    let categories = [];\n    feed.itunes = {}\n\n    if (channel['itunes:owner']) {\n      let owner = {};\n\n      if(channel['itunes:owner'][0]['itunes:name']) {\n        owner.name = channel['itunes:owner'][0]['itunes:name'][0];\n      }\n      if(channel['itunes:owner'][0]['itunes:email']) {\n        owner.email = channel['itunes:owner'][0]['itunes:email'][0];\n      }\n      feed.itunes.owner = owner;\n    }\n\n    if (channel['itunes:image']) {\n      let image;\n      let hasImageHref = (channel['itunes:image'][0] &&\n        channel['itunes:image'][0].$ &&\n        channel['itunes:image'][0].$.href);\n      image = hasImageHref ? channel['itunes:image'][0].$.href : null;\n      if (image) {\n        feed.itunes.image = image;\n      }\n    }\n\n    if (channel['itunes:category']) {\n      const categoriesWithSubs = channel['itunes:category'].map((category) => {\n        return {\n          name: category.$.text,\n          subs: category['itunes:category'] ?\n            category['itunes:category']\n              .map((subcategory) => ({ name: subcategory.$.text })) : null,\n        };\n      });\n\n      feed.itunes.categories = categoriesWithSubs.map((category) => category.name);\n      feed.itunes.categoriesWithSubs = categoriesWithSubs;\n    }\n\n    if (channel['itunes:keywords']) {\n      if (channel['itunes:keywords'].length > 1) {\n        feed.itunes.keywords = channel['itunes:keywords'].map(\n          keyword => keyword.$.text\n        );\n      } else {\n        let keywords = channel['itunes:keywords'][0];\n        if (keywords && typeof keywords._ === 'string') {\n          keywords = keywords._;\n        }\n\n        if (keywords && keywords.$ && keywords.$.text) {\n          feed.itunes.keywords = keywords.$.text.split(',')\n        } else if (typeof keywords === \"string\") {\n          feed.itunes.keywords = keywords.split(',');\n        }\n      }\n    }\n\n    utils.copyFromXML(channel, feed.itunes, fields.podcastFeed);\n    items.forEach((item, index) => {\n      let entry = feed.items[index];\n      entry.itunes = {};\n      utils.copyFromXML(item, entry.itunes, fields.podcastItem);\n      let image = item['itunes:image'];\n      if (image && image[0] && image[0].$ && image[0].$.href) {\n        entry.itunes.image = image[0].$.href;\n      }\n    });\n  }\n\n  setISODate(item) {\n    let date = item.pubDate || item.date;\n    if (date) {\n      try {\n        item.isoDate = new Date(date.trim()).toISOString();\n      } catch (e) {\n        // Ignore bad date format\n      }\n    }\n  }\n\n  /**\n   * Generates a pagination object where the rel attribute is the key and href attribute is the value\n   *  { self: 'self-url', first: 'first-url', ...  }\n   *\n   * @access private\n   * @param {Object} channel parsed XML\n   * @returns {Object}\n   */\n  generatePaginationLinks(channel) {\n    if (!channel['atom:link']) {\n      return {};\n    }\n    const paginationRelAttributes = ['self', 'first', 'next', 'prev', 'last'];\n\n    return channel['atom:link'].reduce((paginationLinks, link) => {\n      if (!link.$ || !paginationRelAttributes.includes(link.$.rel)) {\n        return paginationLinks;\n      }\n      paginationLinks[link.$.rel] = link.$.href;\n      return paginationLinks;\n    }, {});\n  }\n}\n\nmodule.exports = Parser;\n"]},"metadata":{},"sourceType":"script"}